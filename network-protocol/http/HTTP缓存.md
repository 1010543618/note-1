## HTTP 缓存解决的问题

* 减少了冗余的数据传输
* 缓解带宽瓶颈的问题
* 解决瞬间拥塞
* 降低距离时延



## 缓存命中

直接从缓存服务器响应资源给客户端, 而不是从原始服务器响应资源给客户端.



## 再验证

缓存服务器需要向原始服务器验证本地的副本是否新鲜, 所以缓存服务器在缓存未命中的时候会向原始服务器发起一个验证请求, 如果内容没有变化, 则原始服务器响应一个 304, 称为再验证命中或缓慢命中, 这比缓存命中要慢, 但是比从原始服务器响应要快, 毕竟不需要原始服务器跨越更远的距离响应完整的资源.

再验证是通过 `If-Modified-Since` 头部完成, 即缓存服务器向原始服务器发起请求带有该头部, 询问资源自某一时间之后是否未修改, 如果是, 则原始服务器响应 304 Not Modified, 如果原始服务器资源被删除, 则响应 404, 同时缓存服务器也把本地缓存删掉.

缓存服务器通常规定一个时间范围, 处于该范围内的资源被视为是新鲜的, 资源被直接提供给客户端而不用向原始服务器查询, 如果超过范围, 则进行新鲜度检测, 即再验证, 验证通过则更新本地资源的新鲜度.

怎么确定一个资源什么时候过期? 原始服务器会给响应的资源加上 `Cache-Control` 或 `Expires` 头部, 来指示资源什么时候过期, 过期的资源就不新鲜了, 不过也不意味着缓存资源和原始服务器的资源有实际区别, 对于缓存服务器来说, 它只需要发送一个小的头部(`If-Modified-Since`)询问原始服务器是否变化, 如果没有变化则简单地更新下头部即可. `Cache-Control` 是使用相对时间(`max-age`), 比如 2 小时后过期, `Expires` 则是绝对过期时间, 比如 22:00 过期, 通常用 `Cache-Control` 因为它不依赖计算机的本地时间.

`Cache-Control` 可以有这些值, `no-store`(告诉缓存服务器不要缓存), `no-cache`(告诉缓存服务器可以缓存在本地但是再验证通过之前不能提供给客户端), `must-revalidate`(告诉缓存服务器可以缓存但是下次一定要再验证), `max-age`(设置一个时间, 告诉缓存服务器多久之后过期)

缓存服务器发起再验证请求通常可以包含下面几种头部:

* `If-Modified-Since` 基于时间的再验证, 原始服务器看到这个时间的资源已过期就响应新的资源, 服务器响应中也可以包含 `Last-Modified` 来告诉缓存服务器最近修改的时间
* `If-None-Match` 基于版本号的再验证, 原始服务器看到这个 Tag 和现有 Tag 不一样就响应新的资源, Tag 由原始服务器响应的 `ETag` 字段指定, 下次缓存服务器的再验证请求中 `If-None-Match` 包含的就是原先响应的 `ETag` 字段
* 上面两个都是强缓存, 因为只要内容发生变化, 缓存就会更新, 但是有时候原始服务器希望告诉缓存服务器, 即使内容发生变化, 你也可以继续使用原来的缓存, 这种叫弱缓存验证, 弱验证的话会在上面的头部的值中加 W 前缀



## 私有缓存和公有缓存

一般浏览器这样的客户端做的缓存我们叫私有缓存, 而 CDN 这样的则是公有缓存, 即缓存代理服务器.